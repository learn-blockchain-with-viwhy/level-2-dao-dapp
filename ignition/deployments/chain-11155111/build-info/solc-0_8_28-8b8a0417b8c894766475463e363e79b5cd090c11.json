{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-8b8a0417b8c894766475463e363e79b5cd090c11",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/VotingV2.sol": "project/contracts/VotingV2.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/VotingV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title VotingV2\n * @dev Upgraded version of Voting Contract with additional features\n * This demonstrates how to upgrade the contract while preserving state\n */\ncontract VotingV2 {\n    struct Proposal {\n        uint id;\n        string description;\n        uint voteCount;\n        uint deadline;\n        bool closed;\n    }\n\n    mapping(uint => Proposal) public proposals;\n    mapping(address => mapping(uint => bool)) public hasVoted;\n    uint public proposalCount;\n\n    // Storage slot for proxy admin (to avoid storage collision)\n    address private _admin;\n\n    // Storage slot for implementation address (UUPS pattern)\n    address private _implementation;\n\n    // NEW FEATURES IN V2\n    mapping(uint => mapping(address => bool)) public voteHistory; // Track who voted\n    uint public totalVotes; // Total votes across all proposals\n    uint public version; // Contract version\n\n    event ProposalCreated(uint id, string description, uint deadline);\n    event Voted(address voter, uint proposalId);\n    event Upgraded(address newImplementation);\n    event ProposalClosed(uint id, uint finalVoteCount); // New event in V2\n\n    modifier onlyAdmin() {\n        require(msg.sender == _admin, 'Only admin can call this function');\n        _;\n    }\n\n    // Initialize function (called once via proxy)\n    function initialize() external {\n        require(_admin == address(0), 'Already initialized');\n        // Admin will be set by proxy, we just mark as initialized\n    }\n\n    // Initialize function for V2 (only called if upgrading from V1)\n    function initializeV2() external {\n        require(version == 0, 'V2 already initialized');\n        version = 2;\n    }\n\n    function createProposal(string memory _desc, uint _duration) external {\n        proposalCount++;\n        proposals[proposalCount] = Proposal(\n            proposalCount,\n            _desc,\n            0,\n            block.timestamp + _duration,\n            false\n        );\n        emit ProposalCreated(proposalCount, _desc, block.timestamp + _duration);\n    }\n\n    function vote(uint _proposalId) external {\n        Proposal storage prop = proposals[_proposalId];\n        require(block.timestamp < prop.deadline, 'Voting closed');\n        require(!hasVoted[msg.sender][_proposalId], 'Already voted');\n\n        prop.voteCount += 1;\n        hasVoted[msg.sender][_proposalId] = true;\n        voteHistory[_proposalId][msg.sender] = true; // V2: Track vote history\n        totalVotes += 1; // V2: Track total votes\n        emit Voted(msg.sender, _proposalId);\n    }\n\n    function closeVote(uint _proposalId) external {\n        Proposal storage prop = proposals[_proposalId];\n        require(block.timestamp >= prop.deadline, 'Too early');\n        require(!prop.closed, 'Already closed');\n        prop.closed = true;\n        emit ProposalClosed(_proposalId, prop.voteCount); // V2: Enhanced event\n    }\n\n    function getProposals() external view returns (Proposal[] memory) {\n        Proposal[] memory all = new Proposal[](proposalCount);\n        for (uint i = 1; i <= proposalCount; i++) {\n            all[i - 1] = proposals[i];\n        }\n        return all;\n    }\n\n    // V2: New function to get vote history for a proposal\n    function getVoters(\n        uint _proposalId\n    ) external view returns (address[] memory) {\n        // Note: This is a simplified version. In production, you'd need to track voters\n        // This function demonstrates new functionality in V2\n        return new address[](0); // Placeholder\n    }\n\n    // V2: New function to get contract version\n    function getVersion() external view returns (uint) {\n        return version;\n    }\n\n    // UUPS upgrade function\n    function upgradeTo(address newImplementation) external onlyAdmin {\n        require(newImplementation != address(0), 'Invalid implementation');\n        _implementation = newImplementation;\n        emit Upgraded(newImplementation);\n    }\n\n    function getImplementation() external view returns (address) {\n        return _implementation;\n    }\n\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n}\n"
      }
    }
  }
}